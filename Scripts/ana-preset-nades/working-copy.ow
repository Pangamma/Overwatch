settings
{
	main
	{
		Description: "Find pre-set nade locations more efficiently. By Pangamma. Last Update: 2022-04-02"
		Mode Name: "Reverse Nade Tool"
	}

	lobby
	{
		Allow Players Who Are In Queue: Yes
		Match Voice Chat: Enabled
		Max Spectators: 6
		Max Team 1 Players: 0
	}

	modes
	{
		Skirmish
		{
			enabled maps
			{
				Blizzard World
				Eichenwalde
				Hollywood
				Junkertown
				King's Row
			}
		}

		General
		{
			Hero Limit: Off
			Kill Feed: Off
			Respawn Time Scalar: 10%
		}
	}

	heroes
	{
		General
		{
			Quick Melee: On
		}
	}

	extensions
	{
		Beam Effects
		Beam Sounds
		Buff Status Effects
		Debuff Status Effects
		Energy Explosion Effects
		Kinetic Explosion Effects
		Play More Effects
	}
}

variables
{
	global:
		0: data
		1: loop_i
		2: map_deathplane_y
		3: heroList
		4: heroData
		5: mapCode
		6: mapVersion
		7: g_enableVerticalAimLine
		9: g_enableHelpText
		10: g_HelpTextSecondsPerColor
		11: g_aimAccuracyBaseStepSize
		12: g_enableDevMode
		20: helpTextColor
		21: aimAccuracyStepSize
		100: _FX

	player:
		0: abilityIndex
		1: aimTargetPos
		2: aim_distToIndicator
		3: aim_fastCalcAngleRs
		4: aim_fastCalcDx
		5: aim_fastCalcDy
		6: aim_fastCalcPosA
		7: aim_fastCalcPosB
		8: aim_indicatorPos
		9: aim_vLinePos
		10: isNewPlayerTextVisible
		11: chasecam_bool
		12: chasecam_chasing
		13: chasecam_interrupt
		14: chasecam_t
		15: eye_height
		17: freecam_bool
		21: heroAbilityIcon
		22: heroIndex
		23: heroProjData
		24: isAimEnabled
		25: isHudHidden
		26: isTrajHidden
		27: isTrajHidden_manual
		29: pEyePos
		30: pFacingDir
		31: pFacingDirHidden
		32: player_hero
		33: posMemory
		34: poslock_bool
		35: poslock_posfac
		36: predictcam_bool
		37: predictcam_dist
		38: proj_apex_t
		39: proj_castdelay
		40: proj_chasedelay
		41: proj_del
		42: proj_dir
		43: proj_fx
		44: proj_g
		45: proj_override
		46: proj_p0
		47: proj_p1
		48: proj_p2
		49: proj_predict_land_pos
		50: proj_predict_land_t
		51: proj_r
		52: proj_simtime
		53: proj_vel
		54: proj_warning
		55: ray_cast_end
		56: ray_cast_hit_pos
		57: ray_cast_start
		58: ray_cast_t
		59: trajlock_bool
		60: tumbleweed_highnoon_swag
		61: aim_msgAlignHoriz
		62: aim_msgAlignVert
		64: aim_fastCalc_dAngle_H
		65: aim_fastCalc_dAngle_V
		66: aim_indicatorIconIndex
		67: proj_hitRadiusPrimary
		69: calcsBeforeExit
		70: calcsBeforeExitAvg
		80: predictTraj_launchDir
		81: predictTraj_launchPos
		82: predictTraj_outputPos
		83: predictTraj_canHitTarget
		85: predictTraj__p1
		86: predictTraj__p2
		87: predictTraj__apex_t
		88: predictTraj__rc_t
		89: predictTraj__rc_start
		90: predictTraj__rc_end
		91: predictTraj__rc_hit_pos
}

subroutines
{
	0: loadProjData
	1: calc_proj
	2: swap_proj_data
	3: init_map_deathplane_y
	4: initTrajectoryUI
	5: initWorkshopSettings
	6: initHud
	7: save_trajectory_origin
	8: chasecam_start
	9: lockpos_only
	11: unlockpos_only
	14: initAutoAim
	15: initHeroData
	16: calcAimParamsLoopAction
	17: calcAimDxAndDy
	18: calcAimParamsFastUpper
	20: calcCanProjHitTarget
	21: calcAimIndicatorIconIndex
}

disabled rule("Credits and Contributions")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		"Pangamma - Developer of this code"
		disabled Break;
		"Zezombye - Answered some workshop questions I had"
		disabled Break;
		"pluzorminuz - A LOT of the trajectory code from this was originally made by pluzorminuz. I'm basically only responsible for the auto aiming system. You can see his original workshop code here: XWAGN"
		disabled Break;
	}
}

disabled rule("S E T U P")
{
	event
	{
		Ongoing - Global;
	}
}

rule("init")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		If(!Global.g_enableDevMode);
			Disable Inspector Recording;
		End;
		"sphere,shaft 1.053046257,ringout 1.052807897,ringin 1.062128122"
		Global._FX = Array(1.016, 1.053, 1.053, 1.062);
		Global.mapCode = Custom String("M72P9V");
		Global.mapVersion = Custom String("1.4.2");
		Call Subroutine(initWorkshopSettings);
		Call Subroutine(initHeroData);
		Call Subroutine(initHud);
		Call Subroutine(init_map_deathplane_y);
		Call Subroutine(initTrajectoryUI);
	}
}

rule("[sub] initWorkshopSettings")
{
	event
	{
		Subroutine;
		initWorkshopSettings;
	}

	actions
	{
		Global.g_enableVerticalAimLine = Workshop Setting Toggle(Custom String("Aim Calculator"), Custom String("Enable Vertical Line"),
			False, 0);
		Global.g_aimAccuracyBaseStepSize = Workshop Setting Real(Custom String("Aim Calculator"), Custom String(
			"Step Size (Lower = more accurate)"), 0.040, 0.020, 0.120, 0);
		Global.aimAccuracyStepSize = Max(0.012, Global.g_aimAccuracyBaseStepSize * Count Of(All Players(All Teams)) / 10);
		Global.g_enableHelpText = Workshop Setting Toggle(Custom String("Newbie Text"), Custom String("Enable"), True, 0);
		Global.g_HelpTextSecondsPerColor = Workshop Setting Real(Custom String("Newbie Text"), Custom String("Seconds per color"), 0.100,
			0.120, 5, 0);
		Global.g_enableDevMode = Workshop Setting Toggle(Custom String("Other"), Custom String("Enable Developer Mode"), False, 0);
	}
}

rule("init_player")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Set Player Allowed Heroes(Event Player, Global.heroList);
		Event Player.isTrajHidden = False;
		Event Player.isTrajHidden_manual = True;
		Event Player.aim_indicatorIconIndex = -1;
		Event Player.isNewPlayerTextVisible = Global.g_enableHelpText;
		Disable Game Mode HUD(Event Player);
		Call Subroutine(initAutoAim);
	}
}

rule("[sub] initHud")
{
	event
	{
		Subroutine;
		initHud;
	}

	actions
	{
		Create HUD Text(Local Player.isHudHidden ? Null : Local Player, Custom String("Code: {0}", Global.mapCode), Custom String(
			"Reverse Nade Tool ({0})", Global.mapVersion), Custom String("by Pangamma"), Left, -3, Color(Yellow), Color(White), Color(
			Aqua), Visible To, Default Visibility);
		Create HUD Text(Local Player.isHudHidden ? Local Player : Null, Null, Null, Custom String("{0} {1}", Global.mapCode,
			Global.mapVersion), Left, -2, Color(White), Color(White), Color(Yellow), Visible To, Default Visibility);
		Create HUD Text(Local Player.isHudHidden ? Null : Local Player, Custom String("Instructions"), Null, Null, Left, -1, Color(White),
			Color(White), Color(White), Visible To and String, Default Visibility);
		"LEFT ALIGNED INSTRUCTIONS"
		disabled Break;
		"Toggle hud"
		Create HUD Text(All Players(All Teams), Null, Custom String("Need Healing/ {0} Spray", String("Down")), Custom String(
			"- [{0}] Toggle HUD", Local Player.isHudHidden ? Custom String("Hidden") : Custom String("Visible")), Left, 1.050, Color(
			White), Color(Gray), Color(White), Visible To and String, Default Visibility);
		"Chase cam"
		Create HUD Text(Local Player.isHudHidden ? Null : Local Player, Null, Custom String("Ultimate {0}/ {1} Spray", String("Status"),
			String("Up")), Custom String("- [{0}] toggle chase camera", Local Player.chasecam_bool ? Custom String("On") : Custom String(
			"Off")), Left, 1.100, Color(White), Color(Blue), Color(White), Visible To and String, Default Visibility);
		"change hero"
		Create HUD Text(Local Player.isHudHidden ? Null : Local Player, Null, Custom String("Acknowledge/ {0} Spray", String("Right")),
			Custom String("- change hero"), Left, 1.150, Color(White), Color(Sky Blue), Color(White), Visible To and String,
			Default Visibility);
		"cycle through trajectory viewer modes"
		Create HUD Text(Local Player.isHudHidden ? Null : Local Player, Null, Custom String("Group Up/ {0} Spray", String("Left")),
			Custom String("- [{0}] hide trajectory / effects", Local Player.isTrajHidden_manual ? Custom String("Hidden") : Custom String(
			"Visible")), Left, 1.200, Color(White), Color(Aqua), Color(White), Visible To and String, Default Visibility);
		"set target"
		Create HUD Text(Local Player.isHudHidden ? Null : Local Player, Null, String("{0} {1}", Button(Interact), String("({0})",
			Input Binding String(Button(Interact)))), Custom String("- [{0}] set/unset target position",
			Local Player.isAimEnabled && Local Player.aimTargetPos != Vector(0, 0, 0) ? Custom String("Set") : Custom String("Unset")),
			Left, 1.250, Color(White), Color(Turquoise), Color(White), Visible To and String, Default Visibility);
		"Auto aim at target."
		Create HUD Text(Local Player.isHudHidden ? Null : Local Player, Null, String("{0} {1}", Button(Reload), String("({0})",
			Input Binding String(Button(Reload)))), Custom String("- Auto aim towards target"), Left, 1.260, Color(White),
			Local Player.isAimEnabled ? Color(Green) : Color(Gray), Local Player.isAimEnabled ? Color(White) : Color(Gray),
			Visible To String and Color, Default Visibility);
		"Target cam / cancel chase cam in progress"
		Create HUD Text(Local Player.isHudHidden ? Null : Local Player, Null, String("{0} {1}", Button(Melee), String("({0})",
			Input Binding String(Button(Melee)))), Local Player.chasecam_chasing ? Custom String("- cancel chase cam in-progress")
			: Custom String("- [{0}] toggle landing spot view", Local Player.predictcam_bool ? Custom String("On") : Custom String("Off")),
			Left, 1.350, Color(White), Color(Lime Green), Color(White), Visible To and String, Default Visibility);
		"jump / crouch"
		Create HUD Text(Local Player.isHudHidden ? Null : Local Player, Null, String("{0} and {1}", String("{0} {1}", Button(Jump), String(
			"({0})", Input Binding String(Button(Jump)))), String("{0} {1}", Button(Crouch), String("({0})", Input Binding String(Button(
			Crouch))))), Custom String("- zoom out or in while locked and in landing spot view"), Left, 1.400, Color(White),
			Local Player.predictcam_bool ? Color(Yellow) : Color(Gray), Local Player.predictcam_bool ? Color(White) : Color(Gray),
			Visible To String and Color, Default Visibility);
		Create HUD Text(Local Player.isHudHidden ? Null : Local Player, Custom String("Abilities ({0})", Local Player.heroAbilityIcon),
			Null, Null, Left, 5, Color(Blue), Color(White), Color(White), Visible To and String, Default Visibility);
		"RIGHT ALIGNED DEBUG"
		disabled Break;
		Create HUD Text(Local Player.isHudHidden ? Null : Local Player, Null, Custom String("Proj Speed"), Distance Between(2 * (
			1 - Local Player.chasecam_t) * (Local Player.proj_p1 - Local Player.proj_p0) + 2 * Local Player.chasecam_t * (
			Local Player.proj_p2 - Local Player.proj_p1), Vector(0, 0, 0)) / Local Player.proj_simtime, Right, 3.050, Color(White), Color(
			White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Local Player.isHudHidden ? Null : Local Player, Null, Custom String("Flight Time (Approx)"),
			Local Player.proj_simtime * Local Player.proj_predict_land_t, Right, 3.100, Color(White), Color(White), Color(White),
			Visible To and String, Default Visibility);
		If(Global.g_enableDevMode);
			Create HUD Text(Local Player.isHudHidden || Host Player != Local Player ? Null : Local Player, Null, Custom String(
				"Average calcs per cycle [stepSize={0}/10]", 10 * Global.aimAccuracyStepSize), Local Player.calcsBeforeExitAvg, Right, 6,
				Color(Gray), Color(Gray), Color(Gray), Visible To and String, Default Visibility);
			Create HUD Text(Host Player, Null, Custom String("Ents={0} - Texts={1}", Entity Count, Text Count), Custom String(
				"Load now={0}, avg={1}, peak={2}", Server Load, Server Load Average, Server Load Peak), Right, 5.050, Color(White), Color(
				Gray), Color(Gray), Visible To and String, Default Visibility);
		End;
		"TOP Aligned Indicators"
		disabled Break;
		"vertical launch angle"
		Create HUD Text(Local Player.isHudHidden || !Local Player.isAimEnabled ? Null : Local Player, Null, Custom String(
			"Vertical   launch   angle"), Local Player.aim_msgAlignVert, Top, -4, Color(White), Color(White), Color(Yellow),
			Visible To and String, Default Visibility);
		"horizontal launch angle"
		Create HUD Text(Local Player.isHudHidden || !Local Player.isAimEnabled ? Null : Local Player, Null, Custom String(
			"Horizontal launch angle"), Local Player.aim_msgAlignHoriz, Top, -2, Color(White), Color(White), Color(Yellow),
			Visible To and String, Default Visibility);
		"Can the target be hit at all?"
		Create HUD Text(
			!Local Player.predictTraj_canHitTarget && !Local Player.isHudHidden && Local Player.isAimEnabled ? Local Player : Null,
			Icon String(Warning), Custom String("Your current target"), Custom String("cannot be reached."), Top, 20, Color(Red), Color(
			Orange), Color(Orange), Visible To and String, Default Visibility);
		Create HUD Text(!Local Player.isHudHidden && Local Player.proj_warning ? Local Player : Null, Custom String(
			"NON-ZERO PROJECTILE RADIUS. TRAJECTORY MAY NOT MATCH"), Null, Null, Top, 30, Color(Red), Color(White), Color(White),
			Visible To, Default Visibility);
		Create HUD Text(Local Player.isNewPlayerTextVisible ? Local Player : Null, Icon String(Stop), Custom String(
			"You can get started quickly:"), Custom String("First press '{0}' and then press '{1}'.", Input Binding String(Button(
			Interact)), Input Binding String(Button(Reload))), Top, 90, Global.helpTextColor, Global.helpTextColor, Color(White),
			Visible To String and Color, Default Visibility);
	}
}

rule("[sub] load heroData")
{
	event
	{
		Subroutine;
		initHeroData;
	}

	actions
	{
		Global.heroList = Array(Hero(Ana), Hero(Junkrat), Hero(Baptiste), Hero(Orisa), Hero(Zarya), Hero(Sombra), Hero(Ashe), Hero(Tracer),
			Hero(Cassidy), Hero(Mei), Hero(Torbjörn), Hero(Hanzo), Hero(Sigma), Hero(Widowmaker));
		Global.heroData = Array();
		"Ana"
		Global.heroData[0] = Array(Array(Null, Null, Null, Null, Array(-9.840, 30, 0, 7, 0, 0, 0.350, False)), 4, Array(4, 0, 0), False);
		"Junkrat"
		Global.heroData[1] = Array(Array(Array(-12.350, 25, 0.075, 7, 0, 0, 0.100, False), Null, Null, Array(-20.300, 25, 0.090, 7, 0,
			0.136, 0.250, False), Array(-20.200, 10, 0.095, 7, 0, 0, 0.250, False)), 0, Array(2, 3, 0), True);
		"Baptiste"
		Global.heroData[2] = Array(Array(Null, Array(-20.100, 60, 0.007, 7, 0, 0, 0.100, False), Null, Null, Array(-20.100, 60, 0.007, 7,
			0, 0, 0.100, False)), 1, Array(3, 0, 6.500), True);
		"Orisa"
		Global.heroData[3] = Array(Array(Null, Null, Null, Null, Array(-9.840, 25, 0, 7, 0, 0.128, 0.400, False)), 4, Array(0, 0, 0),
			True);
		"Zarya"
		Global.heroData[4] = Array(Array(Null, Array(-9.840, 25, 0.100, 7, 0, 0, 0.500, False), Array(-9.840, 25, 0.100, 7, 0, 0, 0.500,
			False), Null, Null), 1, Array(2.500, 6, 0), False);
		"Sombra"
		Global.heroData[5] = Array(Array(Null, Null, Null, Null, Array(-20.200, 25, 0.090, 5, 0, 0.096, 0.200, False)), 4, Array(15, 0, 0),
			True);
		"Ashe"
		Global.heroData[6] = Array(Array(Null, Null, Null, Null, Array(-8.030, 25, 0.070, 7, 0, 0.140, 0.400, False)), 4, Array(5, 0, 0),
			True);
		"Tracer"
		Global.heroData[7] = Array(Array(Null, Null, Array(-30.800, 15, 0.190, 2, 0, 0.144, 0.150, False), Null, Null), 2, Array(5, 0, 0),
			False);
		"Cassidy"
		Global.heroData[8] = Array(Array(Null, Null, Array(-10, 4.200, 0.577, 4, 0, 0, 0.300, False), Null, Array(-9.840, 30, 0, 0.233, 0,
			0, 0.100, False)), 4, Array(3, 0, 0), False);
		"Mei"
		Global.heroData[9] = Array(Array(Null, Null, Array(-9.900, 20, 0.090, 7, 0, 0.484, 0.600, False), Null, Null), 2, Array(10, 0, 0),
			False);
		"Torbjörn"
		Global.heroData[10] = Array(Array(Array(-9.810, 70, 0.015, 15, 0, 0, 0.100, True), Null, Array(-30.050, 40, 0, 5, 0, 0, 0.100,
			True), Array(-20, 17, 0, 4, 0, 0.048, 0.100, True), Null), 0, Array(2.500, 40, 0), True);
		"Hanzo"
		Global.heroData[11] = Array(Array(Array(-9.815, 110, 0, 15, 0, 0, 0.032, True), Null, Null, Null, Array(-9.815, 110, 0, 15, 0, 0,
			0.032, True)), 0, Array(0, 9, 0), False);
		"Sigma"
		Global.heroData[12] = Array(Array(Array(-5.954, 49.700, 0, 0.429, 0, 0, 0.048, False), Null, Null, Null, Array(-18.350, 37.400,
			0.100, 6, 0, 0.640, 0.256, False)), 4, Array(2.500, 3, 0), True);
		"Widowmaker"
		Global.heroData[13] = Array(Array(Null, Null, Null, Null, Array(-9.840, 20, 0, 7, 0, 0.192, 0.160, False)), 4, Array(3, 0, 0),
			True);
		Global.data = Array(Global.heroList, Global.heroData);
	}
}

rule("[sub] map_deathplane")
{
	event
	{
		Subroutine;
		init_map_deathplane_y;
	}

	actions
	{
		If(Current Map == Map(Blizzard World));
			Global.map_deathplane_y = -6.490;
		Else If(Current Map == Map(Blizzard World Winter));
			Global.map_deathplane_y = -6.490;
		Else If(Current Map == Map(Dorado));
			Global.map_deathplane_y = -9.510;
		Else If(Current Map == Map(Eichenwalde));
			Global.map_deathplane_y = -7.720;
		Else If(Current Map == Map(Eichenwalde Halloween));
			Global.map_deathplane_y = -7.710;
		Else If(Current Map == Map(Hanamura));
			Global.map_deathplane_y = -8.510;
		Else If(Current Map == Map(Hanamura Winter));
			Global.map_deathplane_y = -8.500;
		Else If(Current Map == Map(Havana));
			Global.map_deathplane_y = -8.500;
		Else If(Current Map == Map(Hollywood));
			Global.map_deathplane_y = -30.510;
		Else If(Current Map == Map(Hollywood Halloween));
			Global.map_deathplane_y = -30.500;
		Else If(Current Map == Map(Horizon Lunar Colony));
			Global.map_deathplane_y = 0.410;
		Else If(Current Map == Map(Junkertown));
			Global.map_deathplane_y = -5.500;
		Else If(Current Map == Map(King's Row));
			Global.map_deathplane_y = -18.500;
		Else If(Current Map == Map(King's Row Winter));
			Global.map_deathplane_y = -18.500;
		Else If(Current Map == Map(Numbani));
			Global.map_deathplane_y = -10.500;
		Else If(Current Map == Map(Paris));
			Global.map_deathplane_y = 6.150;
		Else If(Current Map == Map(Rialto));
			Global.map_deathplane_y = -15.500;
		Else If(Current Map == Map(Route 66));
			Global.map_deathplane_y = -15.500;
		Else If(Current Map == Map(Temple of Anubis));
			Global.map_deathplane_y = -10.500;
		Else If(Current Map == Map(Volskaya Industries));
			Global.map_deathplane_y = -12.500;
		Else If(Current Map == Map(Watchpoint: Gibraltar));
			Global.map_deathplane_y = -18.500;
		Else If(Current Map == Map(Busan));
			If(Objective Index == 0);
				Global.map_deathplane_y = 0.410;
			Else If(Objective Index == 1);
				Global.map_deathplane_y = 2.020;
			Else If(Objective Index == 2);
				Global.map_deathplane_y = -8.500;
			End;
		Else If(Current Map == Map(Ilios));
			If(Objective Index == 0);
				Global.map_deathplane_y = -37.450;
			Else If(Objective Index == 1);
				Global.map_deathplane_y = -10.190;
			Else If(Objective Index == 2);
				Global.map_deathplane_y = 49.360;
			End;
		Else If(Current Map == Map(Nepal));
			If(Objective Index == 0);
				Global.map_deathplane_y = -106.180;
			Else If(Objective Index == 1);
				Global.map_deathplane_y = 0.840;
			Else If(Objective Index == 2);
				Global.map_deathplane_y = 115.150;
			End;
		Else If(Current Map == Map(Oasis));
			If(Objective Index == 0);
				Global.map_deathplane_y = -8.990;
			Else If(Objective Index == 1);
				Global.map_deathplane_y = -0.510;
			Else If(Objective Index == 2);
				Global.map_deathplane_y = 2.080;
			End;
		Else If(Current Map == Map(Lijiang Tower));
			If(Objective Index == 0);
				Global.map_deathplane_y = -12.510;
			Else If(Objective Index == 1);
				Global.map_deathplane_y = 82.570;
			Else If(Objective Index == 2);
				Global.map_deathplane_y = 250.200;
			End;
		Else If(Current Map == Map(Lijiang Tower Lunar New Year));
			If(Objective Index == 0);
				Global.map_deathplane_y = -12.510;
			Else If(Objective Index == 1);
				Global.map_deathplane_y = 82.570;
			Else If(Objective Index == 2);
				Global.map_deathplane_y = 250.200;
			End;
		Else If(Current Map == Map(Workshop Chamber));
			Global.map_deathplane_y = -25.500;
		Else If(Current Map == Map(Workshop Expanse));
			Global.map_deathplane_y = -27;
		Else If(Current Map == Map(Workshop Expanse Night));
			Global.map_deathplane_y = -27;
		Else If(Current Map == Map(Workshop Green Screen));
			Global.map_deathplane_y = -27;
		Else If(Current Map == Map(Workshop Island));
			Global.map_deathplane_y = -27;
		Else If(Current Map == Map(Workshop Island Night));
			Global.map_deathplane_y = -27;
		Else;
			Global.map_deathplane_y = -200;
		End;
	}
}

rule("[sub] initTrajectoryUI")
{
	event
	{
		Subroutine;
		initTrajectoryUI;
	}

	actions
	{
		For Global Variable(loop_i, 0, 1, 0.020);
			"main trajectory"
			Create Beam Effect(Local Player.isTrajHidden != True && Local Player.isTrajHidden_manual != True ? Local Player : Null,
				Torbjörn Turret Sight Beam, Evaluate Once((0.980 - Global.loop_i) * (0.980 - Global.loop_i))
				* Local Player.proj_p0 + Evaluate Once(2 * (Global.loop_i + 0.020) * (0.980 - Global.loop_i))
				* Local Player.proj_p1 + Evaluate Once((Global.loop_i + 0.020) * (Global.loop_i + 0.020)) * Local Player.proj_p2,
				Evaluate Once((1 - Global.loop_i) * (1 - Global.loop_i)) * Local Player.proj_p0 + Evaluate Once(2 * Global.loop_i * (
				1 - Global.loop_i)) * Local Player.proj_p1 + Evaluate Once(Global.loop_i * Global.loop_i) * Local Player.proj_p2, Color(
				Team 1), Visible To Position and Radius);
			Wait(0.016, Ignore Condition);
		End;
		"hit position marker"
		Create Effect(Local Player.isTrajHidden_manual ? Null : Local Player, Sphere, Color(Red), Local Player.proj_predict_land_pos,
			0.200 * Evaluate Once(Global._FX[0]), Visible To Position and Radius);
		"primary range"
		Create Effect(Local Player.isTrajHidden_manual ? Null : Local Player, Sphere, Color(Sky Blue), Local Player.proj_predict_land_pos,
			Local Player.proj_fx[0] * Evaluate Once(Global._FX[0]), Visible To Position and Radius);
		"secondary range"
		Create Effect(Local Player.isTrajHidden_manual ? Null : Local Player, Sphere, Color(Blue), Local Player.proj_predict_land_pos,
			Local Player.proj_fx[1] * Evaluate Once(Global._FX[0]), Visible To Position and Radius);
		"cylinder range"
		Create Effect(Local Player.isTrajHidden_manual ? Null : Local Player, Light Shaft, Color(Blue), Local Player.proj_predict_land_pos,
			Local Player.proj_fx[2] * Evaluate Once(Global._FX[1]), Visible To Position and Radius);
		"cylinder range (ring)"
		Create Effect(Local Player.isTrajHidden_manual ? Null : Local Player, Ring, Color(Blue), Local Player.proj_predict_land_pos,
			Local Player.proj_fx[2] * Evaluate Once(Global._FX[2]), Visible To Position and Radius);
	}
}

rule("Flashing Color Changer")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.helpTextColor = Color(Violet);
		Wait(Global.g_HelpTextSecondsPerColor, Ignore Condition);
		Global.helpTextColor = Color(Blue);
		Wait(Global.g_HelpTextSecondsPerColor, Ignore Condition);
		Global.helpTextColor = Color(Aqua);
		Wait(Global.g_HelpTextSecondsPerColor, Ignore Condition);
		Global.helpTextColor = Color(Turquoise);
		Wait(Global.g_HelpTextSecondsPerColor, Ignore Condition);
		Global.helpTextColor = Color(Green);
		Wait(Global.g_HelpTextSecondsPerColor, Ignore Condition);
		Global.helpTextColor = Color(Lime Green);
		Wait(Global.g_HelpTextSecondsPerColor, Ignore Condition);
		Global.helpTextColor = Color(Yellow);
		Wait(Global.g_HelpTextSecondsPerColor, Ignore Condition);
		Global.helpTextColor = Color(Orange);
		disabled Global.helpTextColor = Color(White);
		disabled Wait(30 * Global.g_HelpTextSecondsPerColor, Ignore Condition);
		Wait(Global.g_HelpTextSecondsPerColor, Ignore Condition);
		Global.helpTextColor = Color(Orange);
		Wait(Global.g_HelpTextSecondsPerColor, Ignore Condition);
		Global.helpTextColor = Color(Yellow);
		Wait(Global.g_HelpTextSecondsPerColor, Ignore Condition);
		Global.helpTextColor = Color(Lime Green);
		Wait(Global.g_HelpTextSecondsPerColor, Ignore Condition);
		Global.helpTextColor = Color(Green);
		Wait(Global.g_HelpTextSecondsPerColor, Ignore Condition);
		Global.helpTextColor = Color(Turquoise);
		Wait(Global.g_HelpTextSecondsPerColor, Ignore Condition);
		Global.helpTextColor = Color(Aqua);
		Wait(Global.g_HelpTextSecondsPerColor, Ignore Condition);
		Global.helpTextColor = Color(Blue);
		Wait(Global.g_HelpTextSecondsPerColor, Ignore Condition);
		Global.helpTextColor = Color(Violet);
		Wait(Global.g_HelpTextSecondsPerColor, Ignore Condition);
		Loop;
	}
}

disabled rule("S U B _ R O U T I N E S")
{
	event
	{
		Ongoing - Global;
	}
}

rule("[sub] swap_projectile_data")
{
	event
	{
		Subroutine;
		swap_proj_data;
	}

	actions
	{
		Event Player.proj_g = Event Player.heroProjData[Event Player.abilityIndex][0];
		Event Player.proj_vel = Event Player.heroProjData[Event Player.abilityIndex][1];
		Event Player.proj_del = Event Player.heroProjData[Event Player.abilityIndex][2];
		Event Player.proj_simtime = Event Player.heroProjData[Event Player.abilityIndex][3];
		Event Player.proj_r = Event Player.heroProjData[Event Player.abilityIndex][4];
		Event Player.proj_castdelay = Event Player.heroProjData[Event Player.abilityIndex][5];
		Event Player.proj_chasedelay = Event Player.heroProjData[Event Player.abilityIndex][6];
		Event Player.proj_override = Event Player.heroProjData[Event Player.abilityIndex][7];
	}
}

rule("[sub] save_eye_and_fac")
{
	event
	{
		Subroutine;
		save_trajectory_origin;
	}

	actions
	{
		If(Event Player.tumbleweed_highnoon_swag);
			Event Player.pEyePos = World Vector Of(Vector(6.595, 0.430, 3), Event Player, Rotation And Translation);
			Event Player.pFacingDir = Facing Direction Of(Event Player);
			Event Player.pFacingDirHidden = Normalize(World Vector Of(Right, Event Player, Rotation) + Event Player.proj_del * Up);
		Else;
			Event Player.pEyePos = Eye Position(Event Player);
			Event Player.pFacingDir = Facing Direction Of(Event Player);
			Event Player.pFacingDirHidden = Vertical Facing Angle Of(Event Player) < -89 ? Up : (Vertical Facing Angle Of(Event Player)
				> 89 ? Down : Normalize(Facing Direction Of(Event Player) + Event Player.proj_del * Up));
		End;
		Set Melee Enabled(Event Player, !Event Player.predictcam_bool && Vertical Facing Angle Of(Event Player) > -25);
	}
}

rule("player_calc_proj_loop")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.chasecam_chasing != True;
		Event Player.trajlock_bool != True;
		Event Player.freecam_bool != True;
	}

	actions
	{
		Call Subroutine(save_trajectory_origin);
		Call Subroutine(calc_proj);
		Call Subroutine(calcAimParamsLoopAction);
		Wait(0.064, Abort When False);
		Loop If Condition Is True;
	}
}

rule("[sub] loadProjData")
{
	event
	{
		Subroutine;
		loadProjData;
	}

	actions
	{
		Event Player.heroIndex = Index Of Array Value(Global.heroList, Hero Of(Event Player));
		Event Player.heroProjData = Global.heroData[Event Player.heroIndex][0];
		Event Player.abilityIndex = Global.heroData[Event Player.heroIndex][1];
		Event Player.proj_fx = Global.heroData[Event Player.heroIndex][2];
		Event Player.proj_warning = Global.heroData[Event Player.heroIndex][3];
		Event Player.proj_hitRadiusPrimary = Event Player.proj_fx[0] * Evaluate Once(Global._FX[0]);
		Call Subroutine(swap_proj_data);
	}
}

rule("[sub] calculate_projectile_parameters    (calc_proj)")
{
	event
	{
		Subroutine;
		calc_proj;
	}

	actions
	{
		Event Player.proj_p0 = Event Player.pEyePos;
		Event Player.proj_dir = Event Player.pFacingDirHidden;
		Event Player.proj_p1 = Event Player.proj_p0 + 0.500 * Event Player.proj_vel * Event Player.proj_simtime * Event Player.proj_dir;
		Event Player.proj_p2 = Event Player.proj_p0 + Event Player.proj_vel * Event Player.proj_simtime * Event Player.proj_dir + 0.500 * Event Player.proj_simtime * Event Player.proj_simtime * Event Player.proj_g * Up;
		Event Player.proj_apex_t = -1 * Y Component Of(Event Player.proj_dir)
			* Event Player.proj_vel / Event Player.proj_g / Event Player.proj_simtime;
		If(Host Player == Event Player || True);
			If(Event Player.proj_r == 0);
				For Player Variable(Event Player, ray_cast_t, 0, 1, 0.002);
					Event Player.ray_cast_start = Evaluate Once((1 - Event Player.ray_cast_t) * (1 - Event Player.ray_cast_t))
						* Event Player.proj_p0 + Evaluate Once(2 * (1 - Event Player.ray_cast_t) * Event Player.ray_cast_t)
						* Event Player.proj_p1 + Evaluate Once(Event Player.ray_cast_t * Event Player.ray_cast_t) * Event Player.proj_p2;
					If(Y Component Of(Event Player.ray_cast_start) < Global.map_deathplane_y);
						Break;
					End;
					Event Player.ray_cast_end = Evaluate Once((0.998 - Event Player.ray_cast_t) * (0.998 - Event Player.ray_cast_t))
						* Event Player.proj_p0 + Evaluate Once(2 * (0.998 - Event Player.ray_cast_t) * (Event Player.ray_cast_t + 0.002))
						* Event Player.proj_p1 + Evaluate Once((Event Player.ray_cast_t + 0.002) * (Event Player.ray_cast_t + 0.002))
						* Event Player.proj_p2;
					Event Player.ray_cast_hit_pos = Ray Cast Hit Position(Event Player.ray_cast_start, Event Player.ray_cast_end, Null, Event Player,
						True);
					"hit something"
					If(Event Player.ray_cast_hit_pos != Event Player.ray_cast_end);
						Break;
					End;
				End;
				"adjustment term"
				Event Player.proj_predict_land_t = Event Player.ray_cast_t + 0.002 * (Distance Between(Event Player.ray_cast_start,
					Event Player.ray_cast_hit_pos) / Distance Between(Event Player.ray_cast_start, Event Player.ray_cast_end));
				Event Player.proj_predict_land_pos = Event Player.ray_cast_hit_pos;
				Wait(0.064, Ignore Condition);
			Else;
				Wait(0.016, Ignore Condition);
			End;
		End;
	}
}

rule("[sub] calcCanProjHitTarget")
{
	event
	{
		Subroutine;
		calcCanProjHitTarget;
	}

	actions
	{
		Event Player.calcsBeforeExit = 0;
		"Skip if calculation already performed."
		If(Event Player.predictTraj_launchPos == Event Player.pEyePos);
			Event Player.calcsBeforeExitAvg = Event Player.calcsBeforeExitAvg + (
				Event Player.calcsBeforeExit - Event Player.calcsBeforeExitAvg) / 10;
			Abort;
		End;
		Event Player.predictTraj_launchPos = Event Player.pEyePos;
		Event Player.predictTraj_launchDir = Direction From Angles(Horizontal Angle From Direction(Direction Towards(Event Player.pEyePos,
			Event Player.aimTargetPos)), 0 - Event Player.aim_fastCalcAngleRs);
		Event Player.predictTraj__p1 = Event Player.predictTraj_launchPos + 0.500 * Event Player.proj_vel * Event Player.proj_simtime * Event Player.predictTraj_launchDir;
		Event Player.predictTraj__p2 = Event Player.predictTraj_launchPos + Event Player.proj_vel * Event Player.proj_simtime * Event Player.predictTraj_launchDir + 0.500 * Event Player.proj_simtime * Event Player.proj_simtime * Event Player.proj_g * Up;
		Event Player.predictTraj__apex_t = -1 * Y Component Of(Event Player.predictTraj_launchDir)
			* Event Player.proj_vel / Event Player.proj_g / Event Player.proj_simtime;
		If(Event Player.proj_r == 0 && Event Player.isAimEnabled == True);
			For Player Variable(Event Player, predictTraj__rc_t, 0, 1, Global.aimAccuracyStepSize);
				Event Player.calcsBeforeExit += 1;
				Event Player.predictTraj__rc_start = Evaluate Once((1 - Event Player.predictTraj__rc_t) * (1 - Event Player.predictTraj__rc_t))
					* Event Player.predictTraj_launchPos + Evaluate Once(2 * (1 - Event Player.predictTraj__rc_t) * Event Player.predictTraj__rc_t)
					* Event Player.predictTraj__p1 + Evaluate Once(Event Player.predictTraj__rc_t * Event Player.predictTraj__rc_t)
					* Event Player.predictTraj__p2;
				If(Y Component Of(Event Player.predictTraj__rc_start) < Global.map_deathplane_y);
					Break;
				End;
				Event Player.predictTraj__rc_end = Evaluate Once((1 - Global.aimAccuracyStepSize - Event Player.predictTraj__rc_t) * (
					1 - Global.aimAccuracyStepSize - Event Player.predictTraj__rc_t)) * Event Player.predictTraj_launchPos + Evaluate Once(2 * (
					1 - Global.aimAccuracyStepSize - Event Player.predictTraj__rc_t) * (
					Event Player.predictTraj__rc_t + Global.aimAccuracyStepSize)) * Event Player.predictTraj__p1 + Evaluate Once((
					Event Player.predictTraj__rc_t + Global.aimAccuracyStepSize) * (Event Player.predictTraj__rc_t + Global.aimAccuracyStepSize))
					* Event Player.predictTraj__p2;
				Event Player.predictTraj__rc_hit_pos = Ray Cast Hit Position(Event Player.predictTraj__rc_start, Event Player.predictTraj__rc_end,
					Null, Event Player, True);
				"hit something"
				If(Event Player.predictTraj__rc_hit_pos != Event Player.predictTraj__rc_end);
					Break;
				End;
			End;
			Event Player.predictTraj_canHitTarget = Distance Between(Event Player.predictTraj__rc_hit_pos, Event Player.aimTargetPos)
				< Event Player.proj_hitRadiusPrimary / 2;
			Event Player.predictTraj_outputPos = Event Player.predictTraj__rc_hit_pos;
			Wait(0.064, Ignore Condition);
		End;
		Event Player.calcsBeforeExitAvg = Event Player.calcsBeforeExitAvg + (
			Event Player.calcsBeforeExit - Event Player.calcsBeforeExitAvg) / 10;
	}
}

disabled rule("K E Y _ B I N D S")
{
	event
	{
		Ongoing - Global;
	}
}

rule("[Keybind] refill_ult (Q / Ultimate)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Ultimate)) == True;
	}

	actions
	{
		Set Ultimate Charge(Event Player, 100);
	}
}

rule("[Keybind] change hero (acknowledge)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Is Communicating(Event Player, Acknowledge) || Is Communicating(Event Player, Spray Right)) == True;
	}

	actions
	{
		Event Player.posMemory = Array(Position Of(Event Player), Facing Direction Of(Event Player));
		Set Player Allowed Heroes(Event Player, Filtered Array(All Heroes, Current Array Element != Hero Of(Event Player)));
		Set Player Allowed Heroes(Event Player, Global.heroList);
	}
}

rule("player_changed_hero")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Hero Of(Event Player) != Event Player.player_hero;
	}

	actions
	{
		Event Player.player_hero = Hero Of(Event Player);
		Event Player.eye_height = Eye Position(Event Player) - Position Of(Event Player);
		Call Subroutine(loadProjData);
		Event Player.heroAbilityIcon = Custom String("{0}{1}{2}", Event Player.heroProjData[0] != Null ? Ability Icon String(Hero Of(
			Event Player), Button(Primary Fire)) : Custom String(""), Event Player.heroProjData[1] != Null ? Ability Icon String(Hero Of(
			Event Player), Button(Secondary Fire)) : Custom String(""), Custom String("{0}{1}{2}",
			Event Player.heroProjData[2] != Null ? Ability Icon String(Hero Of(Event Player), Button(Ultimate)) : Custom String(""),
			Event Player.heroProjData[3] != Null ? Ability Icon String(Hero Of(Event Player), Button(Ability 1)) : Custom String(""),
			Event Player.heroProjData[4] != Null ? Ability Icon String(Hero Of(Event Player), Button(Ability 2)) : Custom String("")));
		Set Ultimate Charge(Event Player, 100);
		If(Event Player.posMemory != 0);
			Teleport(Event Player, Event Player.posMemory[0]);
			Set Facing(Event Player, Event Player.posMemory[1], To World);
		End;
		Event Player.predictcam_dist = 0.800;
		Event Player.predictcam_bool = False;
		Event Player.isTrajHidden = False;
		Event Player.tumbleweed_highnoon_swag = False;
		If(Event Player.chasecam_chasing == True);
			Start Rule(chasecam_start, Restart Rule);
		End;
	}
}

rule("[Keybind] trajhide (group up)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Is Communicating(Event Player, Group Up) || Is Communicating(Event Player, Spray Left)) == True;
	}

	actions
	{
		Event Player.isTrajHidden_manual = !Event Player.isTrajHidden_manual;
	}
}

rule("[Keybind] toggle hud (need healing)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Is Communicating(Event Player, Need Healing) || Is Communicating(Event Player, Spray Down)) == True;
	}

	actions
	{
		Event Player.isHudHidden = !Event Player.isHudHidden;
	}
}

rule("[Keybind] set/unset target (interact)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
	}

	actions
	{
		If(Event Player.aimTargetPos == Event Player.proj_predict_land_pos);
			Event Player.isAimEnabled = False;
			Event Player.aimTargetPos = Vector(0, 0, 0);
			Small Message(Event Player, Custom String("Aim target has been unset!"));
		Else;
			Event Player.aimTargetPos = Event Player.proj_predict_land_pos;
			Event Player.isAimEnabled = True;
			Small Message(Event Player, Custom String("Aim target has been set!"));
		End;
	}
}

rule("[Keybind] toggle predictcam (melee)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Melee)) == True;
		Event Player.freecam_bool == False;
		(Vertical Facing Angle Of(Event Player) < -25 || Event Player.predictcam_bool) == True;
	}

	actions
	{
		If(Event Player.chasecam_chasing == False);
			Event Player.poslock_bool = !Event Player.predictcam_bool;
			Event Player.predictcam_bool = !Event Player.predictcam_bool;
		Else;
			Event Player.chasecam_interrupt = True;
			Start Rule(chasecam_start, Restart Rule);
		End;
	}
}

rule("[Keybind] predict cam zoomout (jump)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.poslock_bool == True;
		Is Button Held(Event Player, Button(Jump)) == True;
	}

	actions
	{
		Event Player.predictcam_dist = Max(Event Player.predictcam_dist + -0.003, 0);
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[Keybind] predict cam zoomin (duck)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.poslock_bool == True;
		Is Button Held(Event Player, Button(Crouch)) == True;
	}

	actions
	{
		Event Player.predictcam_dist = Min(Event Player.predictcam_dist + 0.003, 1);
		Wait(0.016, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[Keybind] toggle chasecam (ult status)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		(Is Communicating(Event Player, Ultimate Status) || Is Communicating(Event Player, Spray Up)) == True;
	}

	actions
	{
		Event Player.chasecam_bool = !Event Player.chasecam_bool;
	}
}

rule("[Keybind] auto aim at target (reload)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Reload)) == True;
		Event Player.isAimEnabled == True;
	}

	actions
	{
		Small Message(Event Player, Custom String("Aim set towards target"));
		Set Facing(Event Player, Direction From Angles(Horizontal Facing Angle Of(Event Player) + Horizontal Angle Towards(Event Player,
			Event Player.aimTargetPos), 0 - Event Player.aim_fastCalcAngleRs), To World);
	}
}

rule("[Keybind] mark player as having seen the intro text (reload)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Reload)) == True;
		Event Player.isAimEnabled == True;
		Event Player.isNewPlayerTextVisible == True;
	}

	actions
	{
		Event Player.isNewPlayerTextVisible = False;
	}
}

disabled rule("A B I L I T Y _ S E N S O R S")
{
	event
	{
		Ongoing - Global;
	}
}

rule("check_using_primary")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.proj_override == False;
		Is Button Held(Event Player, Button(Primary Fire)) == True;
	}

	actions
	{
		"immediately snap the starting pos and fac"
		Call Subroutine(save_trajectory_origin);
		Event Player.abilityIndex = 0;
		If(Event Player.heroProjData[Event Player.abilityIndex] != Null);
			Call Subroutine(swap_proj_data);
			If((Event Player.chasecam_bool || Event Player.trajlock_bool) && !Event Player.chasecam_chasing);
				Start Rule(chasecam_start, Restart Rule);
			End;
		End;
	}
}

rule("check_using_secondary")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		disabled Is Firing Secondary(Event Player) == True;
		Event Player.proj_override == False;
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
	}

	actions
	{
		"immediately snap the starting pos and fac"
		Call Subroutine(save_trajectory_origin);
		Event Player.abilityIndex = 1;
		If(Event Player.heroProjData[Event Player.abilityIndex] != Null);
			Call Subroutine(swap_proj_data);
			If((Event Player.chasecam_bool || Event Player.trajlock_bool) && !Event Player.chasecam_chasing);
				Start Rule(chasecam_start, Restart Rule);
			End;
		End;
	}
}

rule("check_using_ultimate")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		disabled Is Using Ultimate(Event Player) == True;
		Event Player.proj_override == False;
		Is Button Held(Event Player, Button(Ultimate)) == True;
	}

	actions
	{
		"immediately snap the starting pos and fac"
		Call Subroutine(save_trajectory_origin);
		Event Player.abilityIndex = 2;
		If(Event Player.heroProjData[Event Player.abilityIndex] != Null);
			Call Subroutine(swap_proj_data);
			If((Event Player.chasecam_bool || Event Player.trajlock_bool) && !Event Player.chasecam_chasing);
				Start Rule(chasecam_start, Restart Rule);
			End;
		End;
	}
}

rule("check_abilityIndex_1")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		disabled Is Using Ability 1(Event Player) == True;
		Event Player.proj_override == False;
		Is Button Held(Event Player, Button(Ability 1)) == True;
	}

	actions
	{
		"immediately snap the starting pos and fac"
		Call Subroutine(save_trajectory_origin);
		Event Player.abilityIndex = 3;
		If(Event Player.heroProjData[Event Player.abilityIndex] != Null);
			Call Subroutine(swap_proj_data);
			If((Event Player.chasecam_bool || Event Player.trajlock_bool) && !Event Player.chasecam_chasing);
				Start Rule(chasecam_start, Restart Rule);
			End;
		End;
	}
}

rule("check_abilityIndex_2")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		disabled Is Using Ability 2(Event Player) == True;
		Event Player.proj_override == False;
		Is Button Held(Event Player, Button(Ability 2)) == True;
	}

	actions
	{
		"immediately snap the starting pos and fac"
		Call Subroutine(save_trajectory_origin);
		Event Player.abilityIndex = 4;
		If(Event Player.heroProjData[Event Player.abilityIndex] != Null);
			Call Subroutine(swap_proj_data);
			If((Event Player.chasecam_bool || Event Player.trajlock_bool) && !Event Player.chasecam_chasing);
				Start Rule(chasecam_start, Restart Rule);
			End;
		End;
	}
}

rule("Hanzo: Primary Fire Charge")
{
	event
	{
		Ongoing - Each Player;
		All;
		Hanzo;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		Is Using Ability 2(Event Player) != True;
	}

	actions
	{
		Event Player.proj_vel = 25;
		Chase Player Variable At Rate(Event Player, proj_vel, 110, 120, None);
		Wait Until(Is Button Held(Event Player, Button(Primary Fire)) == False, 99999);
		"immediately snap the starting pos and fac"
		Call Subroutine(save_trajectory_origin);
		Stop Chasing Player Variable(Event Player, proj_vel);
		If((Event Player.chasecam_bool || Event Player.trajlock_bool) && !Event Player.chasecam_chasing);
			Start Rule(chasecam_start, Restart Rule);
		End;
	}
}

rule("Hanzo: Using Storm Arrow")
{
	event
	{
		Ongoing - Each Player;
		All;
		Hanzo;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		If(Event Player.chasecam_chasing != True);
			Event Player.proj_vel = 110;
		End;
	}
}

rule("Hanzo: Fire Storm Arrow")
{
	event
	{
		Ongoing - Each Player;
		All;
		Hanzo;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		Event Player.chasecam_bool == True;
		Event Player.chasecam_chasing == False;
	}

	actions
	{
		"immediately snap the starting pos and fac"
		Call Subroutine(save_trajectory_origin);
		If((Event Player.chasecam_bool || Event Player.trajlock_bool) && !Event Player.chasecam_chasing);
			Start Rule(chasecam_start, Restart Rule);
		End;
	}
}

rule("Torbjorn: Using Ultimate")
{
	event
	{
		Ongoing - Each Player;
		All;
		Torbjörn;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		If(Event Player.chasecam_chasing != True);
			Event Player.abilityIndex = 2;
			Call Subroutine(swap_proj_data);
		End;
	}
}

rule("Torbjorn: Rivet")
{
	event
	{
		Ongoing - Each Player;
		All;
		Torbjörn;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		Is Using Ultimate(Event Player) != True;
	}

	actions
	{
		"immediately snap the starting pos and fac"
		Call Subroutine(save_trajectory_origin);
		If(Event Player.chasecam_chasing != True);
			Event Player.abilityIndex = 0;
			Call Subroutine(swap_proj_data);
		End;
		If((Event Player.chasecam_bool || Event Player.trajlock_bool) && !Event Player.chasecam_chasing);
			Start Rule(chasecam_start, Restart Rule);
		End;
	}
}

rule("Torbjorn: Firing Goo")
{
	event
	{
		Ongoing - Each Player;
		All;
		Torbjörn;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
		Is Button Held(Event Player, Button(Primary Fire)) == True;
	}

	actions
	{
		"immediately snap the starting pos and fac"
		Call Subroutine(save_trajectory_origin);
		If((Event Player.chasecam_bool || Event Player.trajlock_bool) && !Event Player.chasecam_chasing);
			Start Rule(chasecam_start, Restart Rule);
		End;
	}
}

rule("Torbjorn: Deploy Turret")
{
	event
	{
		Ongoing - Each Player;
		All;
		Torbjörn;
	}

	conditions
	{
		Is Using Ultimate(Event Player) != True;
		Is Button Held(Event Player, Button(Ability 1)) == True;
	}

	actions
	{
		"immediately snap the starting pos and fac"
		Call Subroutine(save_trajectory_origin);
		If(Event Player.chasecam_chasing != True);
			Event Player.abilityIndex = 3;
			Call Subroutine(swap_proj_data);
		End;
		If((Event Player.chasecam_bool || Event Player.trajlock_bool) && !Event Player.chasecam_chasing);
			Start Rule(chasecam_start, Restart Rule);
		End;
	}
}

disabled rule("T A R G E T _ C A M _ S Y S T E M")
{
	event
	{
		Ongoing - Global;
	}
}

rule("[sub] chasecam_start")
{
	event
	{
		Subroutine;
		chasecam_start;
	}

	actions
	{
		If(!(Event Player.chasecam_chasing || Event Player.chasecam_interrupt));
			Stop Chasing Player Variable(Event Player, chasecam_t);
			Event Player.chasecam_t = 0;
			"then wait for the cast time if any"
			If(Event Player.proj_castdelay > 0);
				Wait(Event Player.proj_castdelay, Ignore Condition);
				Call Subroutine(save_trajectory_origin);
			End;
			"do calc"
			Start Rule(calc_proj, Restart Rule);
			"start chasing immediately after casting"
			Chase Player Variable At Rate(Event Player, chasecam_t, Event Player.proj_predict_land_t, 1 / Event Player.proj_simtime,
				Destination and Rate);
			If(Event Player.chasecam_bool && !Event Player.freecam_bool);
				disabled Event Player.predictcam_bool = False;
				Event Player.chasecam_chasing = True;
				Event Player.isTrajHidden = True;
				Set Invisible(Event Player, All);
				"ensures projectile correction"
				Wait(0.016, Ignore Condition);
				"start camera"
				Start Camera(Event Player, Min(1 - Event Player.chasecam_t + Event Player.proj_chasedelay / Event Player.proj_simtime, 1)
					^ 2 * Event Player.proj_p0 + 2 * Min(1 - Event Player.chasecam_t + Event Player.proj_chasedelay / Event Player.proj_simtime, 1)
					* Max(Event Player.chasecam_t - Event Player.proj_chasedelay / Event Player.proj_simtime, 0) * Event Player.proj_p1 + Max(
					Event Player.chasecam_t - Event Player.proj_chasedelay / Event Player.proj_simtime, 0) ^ 2 * Event Player.proj_p2 - (
					Event Player.proj_dir == Up || Event Player.proj_dir == Down) * 0.008 * Direction From Angles(Horizontal Angle From Direction(
					Event Player.pFacingDir), 0), (1 - Event Player.chasecam_t) ^ 2 * Event Player.proj_p0 + 2 * (1 - Event Player.chasecam_t)
					* Event Player.chasecam_t * Event Player.proj_p1 + Event Player.chasecam_t ^ 2 * Event Player.proj_p2, 0);
			End;
			"wait for proj to hit"
			Wait(Event Player.proj_predict_land_t * Event Player.proj_simtime + Event Player.proj_chasedelay + 1.500 - 0.016,
				Abort When False);
		End;
		If(Event Player.chasecam_chasing);
			Stop Camera(Event Player);
		End;
		Set Invisible(Event Player, None);
		Event Player.isTrajHidden = False;
		Event Player.chasecam_interrupt = False;
		Stop Chasing Player Variable(Event Player, chasecam_t);
		Event Player.chasecam_t = 0;
		Event Player.chasecam_chasing = False;
	}
}

rule("predictcam_toggle_on")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.predictcam_bool == True;
	}

	actions
	{
		"final cam"
		Start Camera(Event Player, (1 - Event Player.proj_predict_land_t * Event Player.predictcam_dist) ^ 2 * Event Player.proj_p0 + 2 * (
			1 - Event Player.proj_predict_land_t * Event Player.predictcam_dist)
			* Event Player.proj_predict_land_t * Event Player.predictcam_dist * Event Player.proj_p1 + (
			Event Player.proj_predict_land_t * Event Player.predictcam_dist) ^ 2 * Event Player.proj_p2,
			Event Player.proj_predict_land_pos, 10);
		Call Subroutine(lockpos_only);
	}
}

rule("predictcam_toggle_off")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.predictcam_bool == False;
	}

	actions
	{
		Stop Camera(Event Player);
		Call Subroutine(unlockpos_only);
	}
}

rule("[sub] lockpos_only")
{
	event
	{
		Subroutine;
		lockpos_only;
	}

	actions
	{
		Disable Movement Collision With Environment(Event Player, True);
		Event Player.poslock_posfac[0] = Eye Position(Event Player) - Event Player.eye_height;
		Start Forcing Player Position(Event Player, Event Player.poslock_posfac[0], False);
	}
}

rule("[sub] unlockpos_only")
{
	event
	{
		Subroutine;
		unlockpos_only;
	}

	actions
	{
		Enable Movement Collision With Environment(Event Player);
		Stop Forcing Player Position(Event Player);
	}
}

disabled rule("A U T O _ A I M _ S Y S T E M")
{
	event
	{
		Ongoing - Global;
	}
}

rule("set variables for auto aim")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.isAimEnabled == True;
	}

	actions
	{
		Chase Player Variable At Rate(Event Player, aim_indicatorPos, Eye Position(Event Player) + Vector(5 * Sine From Degrees(
			Horizontal Angle From Direction(Direction Towards(Eye Position(Event Player), Event Player.aimTargetPos))),
			-5 * Tangent From Degrees(Vertical Facing Angle Of(Event Player)), 5 * Cosine From Degrees(Horizontal Angle From Direction(
			Direction Towards(Eye Position(Event Player), Event Player.aimTargetPos)))), 100, Destination and Rate);
		Chase Player Variable At Rate(Event Player, aim_distToIndicator, Distance Between(Eye Position(Event Player),
			Event Player.aim_indicatorPos), 100, Destination and Rate);
		Chase Player Variable At Rate(Event Player, aim_vLinePos, Eye Position(Event Player) + Vector(5 * Sine From Degrees(
			Horizontal Angle From Direction(Direction Towards(Eye Position(Event Player), Event Player.aimTargetPos))), 0,
			5 * Cosine From Degrees(Horizontal Angle From Direction(Direction Towards(Eye Position(Event Player),
			Event Player.aimTargetPos)))), 100, Destination and Rate);
	}
}

rule("[Event] Player Joins")
{
	event
	{
		Player Joined Match;
		All;
		All;
	}

	actions
	{
		Global.aimAccuracyStepSize = Max(0.012, Global.g_aimAccuracyBaseStepSize * Count Of(All Players(All Teams)) / 10);
	}
}

rule("[Event] Player leaves")
{
	event
	{
		Player Left Match;
		All;
		All;
	}

	actions
	{
		Global.aimAccuracyStepSize = Max(0.012, Global.g_aimAccuracyBaseStepSize * Count Of(All Players(All Teams)) / 10);
	}
}

rule("[sub] initAutoAim")
{
	event
	{
		Subroutine;
		initAutoAim;
	}

	actions
	{
		Event Player.aim_indicatorPos = Vector(0, 0, 0);
		Event Player.aimTargetPos = Vector(0, 0, 0);
		Event Player.aim_distToIndicator = 0;
		Event Player.aim_vLinePos = Vector(0, 0, 0);
		"target indicator"
		Create Effect(Event Player.isAimEnabled ? Event Player : Null, Sphere, Color(Black), Event Player.aimTargetPos, 1,
			Visible To Position and Radius);
		Create Effect(Event Player.isAimEnabled ? Event Player : Null, Ring, Color(Black), Event Player.aimTargetPos, 1,
			Visible To Position and Radius);
		Create Icon(Event Player.isAimEnabled ? Event Player : Null, Event Player.aimTargetPos - Vector(0, 0.300, 0), Flag,
			Visible To Position and Color, Distance Between(Local Player.proj_predict_land_pos, Local Player.aimTargetPos)
			< Local Player.proj_hitRadiusPrimary / 2 ? Color(Green) : Color(White), True);
		If(Global.g_enableVerticalAimLine == True);
			"Vertical line, 5m away"
			Create Beam Effect(Local Player.isAimEnabled ? Local Player : Null, Torbjörn Turret Sight Beam, Local Player.aim_vLinePos + Vector(
				0, 70, 0), Local Player.aim_vLinePos - Vector(0, 40, 0), Color(Team 2), Visible To Position Radius and Color);
		End;
		"vertical aim indicator ball"
		Create Effect(Local Player.isAimEnabled ? Local Player : Null, Sphere, Distance Between(Local Player.proj_predict_land_pos,
			Local Player.aimTargetPos) < Local Player.proj_hitRadiusPrimary / 2 ? Color(Green) : Color(White),
			Local Player.aim_indicatorPos, Local Player.aim_distToIndicator / 50, Visible To Position Radius and Color);
		"vAim indicator (Impossible)"
		Create Icon(Local Player.isAimEnabled && Local Player.aim_indicatorIconIndex == -1 ? Local Player : Null,
			Local Player.aim_indicatorPos - Vector(0, 0.300, 0), No, Visible To and Position, Color(Red), False);
		"vAim indicator (HIT)"
		Create Icon(Local Player.isAimEnabled && Local Player.aim_indicatorIconIndex == 0 ? Local Player : Null,
			Local Player.aim_indicatorPos - Vector(0, 0.300, 0), Checkmark, Visible To and Position, Color(Green), False);
		"vAim indicator (MOVE UP)"
		Create Icon(Local Player.isAimEnabled && Local Player.aim_indicatorIconIndex == 1 ? Local Player : Null,
			Local Player.aim_indicatorPos - Vector(0, 0.300, 0), Arrow: Up, Visible To and Position, Color(White), False);
		"vAim indicator (MOVE DOWN)"
		Create Icon(Local Player.isAimEnabled && Local Player.aim_indicatorIconIndex == 2 ? Local Player : Null,
			Local Player.aim_indicatorPos - Vector(0, 0.300, 0), Arrow: Down, Visible To and Position, Color(White), False);
		"vAim indicator (MOVE LEFT)"
		Create Icon(Local Player.isAimEnabled && Local Player.aim_indicatorIconIndex == 3 ? Local Player : Null,
			Local Player.aim_indicatorPos - Vector(0, 0.300, 0), Arrow: Left, Visible To and Position, Color(White), False);
		"vAim indicator (MOVE RIGHT)"
		Create Icon(Local Player.isAimEnabled && Local Player.aim_indicatorIconIndex == 4 ? Local Player : Null,
			Local Player.aim_indicatorPos - Vector(0, 0.300, 0), Arrow: Right, Visible To and Position, Color(White), False);
	}
}

rule("[sub] calcAimParamsLoopAction")
{
	event
	{
		Subroutine;
		calcAimParamsLoopAction;
	}

	actions
	{
		Call Subroutine(calcAimDxAndDy);
		Call Subroutine(calcAimParamsFastUpper);
		Call Subroutine(calcCanProjHitTarget);
		Call Subroutine(calcAimIndicatorIconIndex);
	}
}

rule("[sub] calcAimParamsFastUpper")
{
	event
	{
		Subroutine;
		calcAimParamsFastUpper;
	}

	actions
	{
		"https://stackoverflow.com/a/18048502/1582837"
		Event Player.aim_fastCalcAngleRs = Arctangent In Degrees(Event Player.proj_vel ^ 2 + Square Root(Event Player.proj_vel ^ 4 - (
			0 - Event Player.proj_g) * ((0 - Event Player.proj_g)
			* Event Player.aim_fastCalcDx ^ 2 + 2 * Event Player.aim_fastCalcDy * Event Player.proj_vel ^ 2)), (0 - Event Player.proj_g)
			* Event Player.aim_fastCalcDx);
	}
}

rule("[sub] calcAimIndicatorIconIndex")
{
	event
	{
		Subroutine;
		calcAimIndicatorIconIndex;
	}

	actions
	{
		If(!Event Player.predictTraj_canHitTarget);
			Event Player.aim_indicatorIconIndex = -1;
		Else If(Distance Between(Event Player.proj_predict_land_pos, Event Player.aimTargetPos) < Event Player.proj_hitRadiusPrimary / 2);
			Event Player.aim_indicatorIconIndex = 0;
		Else If(0 - Vertical Facing Angle Of(Event Player) <= Event Player.aim_fastCalcAngleRs && Absolute Value(
				Event Player.aim_fastCalc_dAngle_H) < 5);
			Event Player.aim_indicatorIconIndex = 1;
		Else If(0 - Vertical Facing Angle Of(Event Player) > Event Player.aim_fastCalcAngleRs && Absolute Value(
				Event Player.aim_fastCalc_dAngle_H) < 5);
			Event Player.aim_indicatorIconIndex = 2;
		Else If(Event Player.aim_fastCalc_dAngle_H > 0);
			Event Player.aim_indicatorIconIndex = 3;
		Else If(Event Player.aim_fastCalc_dAngle_H < 0);
			Event Player.aim_indicatorIconIndex = 4;
		End;
	}
}

rule("[sub] calcAimDxAndDy")
{
	event
	{
		Subroutine;
		calcAimDxAndDy;
	}

	actions
	{
		"dX and dY"
		Event Player.aim_fastCalcPosA = Event Player.pEyePos;
		Event Player.aim_fastCalcPosB = Event Player.aimTargetPos;
		Event Player.aim_fastCalcDy = Y Component Of(Event Player.aim_fastCalcPosB) - Y Component Of(Event Player.aim_fastCalcPosA);
		Event Player.aim_fastCalcDx = Distance Between(Vector(X Component Of(Event Player.aim_fastCalcPosA), 0, Z Component Of(
			Event Player.aim_fastCalcPosA)), Vector(X Component Of(Event Player.aim_fastCalcPosB), 0, Z Component Of(
			Event Player.aim_fastCalcPosB)));
		"Angle diff for H and V directions to target"
		Event Player.aim_fastCalc_dAngle_H = Horizontal Angle Towards(Event Player, Event Player.aimTargetPos);
		Event Player.aim_msgAlignHoriz = Event Player.aim_fastCalc_dAngle_H > 1 ? Custom String("{1}    {0}",
			Event Player.aim_fastCalc_dAngle_H, Icon String(Arrow: Left)) : (Event Player.aim_fastCalc_dAngle_H < -1 ? Custom String(
			"{1}    {0}", Event Player.aim_fastCalc_dAngle_H, Icon String(Arrow: Right)) : Icon String(Checkmark));
		Event Player.aim_fastCalc_dAngle_V = Angle Difference(Vertical Facing Angle Of(Event Player), Event Player.aim_fastCalcAngleRs);
		Event Player.aim_msgAlignVert = Custom String("{0}    {1} / {2}", Icon String(Diamond), 0 - Vertical Facing Angle Of(Event Player),
			Event Player.aim_fastCalcAngleRs);
	}
}

disabled rule("A N T I _ C O O L _ D O W N S")
{
	event
	{
		Ongoing - Global;
	}
}

rule("[AntiCoolDowns] - Ability 1")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Ability 1)) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) > 0;
	}

	actions
	{
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
	}
}

rule("[AntiCoolDowns] - Ability 1 (Junkrat + Tracer)")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		disabled Hero Of(Event Player) == Hero(Junkrat);
		Is Button Held(Event Player, Button(Ability 1)) == True;
		Ability Charge(Event Player, Button(Primary Fire)) < 1;
	}

	actions
	{
		Set Ability Charge(Event Player, Button(Ability 1), 1);
	}
}

rule("[AntiCoolDowns] - Ability 2")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Ability 2)) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) > 0;
	}

	actions
	{
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
	}
}

rule("[AntiCoolDowns] - Primary Fire")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		Ability Cooldown(Event Player, Button(Primary Fire)) > 0;
	}

	actions
	{
		Set Ability Cooldown(Event Player, Button(Primary Fire), 0);
	}
}

rule("[AntiCoolDowns] - Secondary Fire")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
		Ability Cooldown(Event Player, Button(Secondary Fire)) > 0;
	}

	actions
	{
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
	}
}

rule("[AntiCoolDowns] - Jump")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Jump)) == True;
		Ability Cooldown(Event Player, Button(Jump)) > 0;
	}

	actions
	{
		Set Ability Cooldown(Event Player, Button(Jump), 0);
	}
}